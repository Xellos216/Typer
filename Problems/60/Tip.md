# Tip: 약수 세기 알고리즘 쉽게 이해하기

이 팁은 Python 코드에서 `count_divisors(n)` 함수가 어떻게 동작하는지, 왜 `int(n ** 0.5)`까지만 반복하는지, 그리고 `i != n // i` 조건이 필요한지를 쉽게 이해하기 위한 설명입니다.

---

## 1. 약수는 쌍으로 존재한다

예를 들어 `n = 36`일 때, 약수 쌍은 다음과 같습니다:

- (1, 36)
- (2, 18)
- (3, 12)
- (4, 9)
- (6, 6) ← 제곱근에서 중복 발생

즉, 어떤 수 `n`의 약수는 항상 `(i, n // i)` 쌍으로 존재합니다.

---

## 2. 왜 1부터 √n까지만 반복하는가?

`n = 36`인 경우:

- 1부터 6까지만 확인해도 `(i, n // i)`의 쌍으로 모든 약수를 찾을 수 있음.
- √n보다 큰 수들은 이미 쌍으로 등장했기 때문.

따라서 `range(1, int(n ** 0.5) + 1)`까지만 반복해도 모든 약수를 효율적으로 찾을 수 있습니다.

---

## 3. 왜 `if i != n // i:` 조건이 필요한가?

- `i`와 `n // i`가 같은 경우는 **제곱수**일 때만 발생
- 예: 6 * 6 = 36 → 중복된 약수
- 이런 경우는 약수 1개만 추가해야 함

따라서 아래 코드는 중복 약수를 걸러냅니다:

```python
if n % i == 0:
    count += 1  # i는 약수
    if i != n // i:
        count += 1  # n // i는 다를 경우만 추가
```

---

## 4. 예시 실행 흐름 (`n = 36`)

| i | n % i == 0? | n // i | count 변화 | 설명 |
|---|-------------|--------|-------------|------|
| 1 | O           | 36     | +2          | (1, 36) |
| 2 | O           | 18     | +2          | (2, 18) |
| 3 | O           | 12     | +2          | (3, 12) |
| 4 | O           | 9      | +2          | (4, 9) |
| 5 | X           | -      | +0          | 약수 아님 |
| 6 | O           | 6      | +1          | 중복 (6, 6) |

총 약수 개수: 9개

---

## ✅ 결론

- √n까지만 검사하면 약수 쌍으로 전체 약수를 알 수 있음
- `i == n // i`는 중복되므로 한 번만 세야 함

이 방식은 효율적이면서 정확한 약수 계산에 사용됩니다.

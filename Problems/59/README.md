## 🧠 Problem
어느 학교에 페인트가 칠해진 길이가 `n`미터인 벽이 있습니다. 벽에 동아리·학회 홍보나 회사 채용 공고 포스터 등을 게시하기 위해 테이프를 붙였다가 철거할 때 페인트가 벗겨지는 경우가 있어, 학교는 벽에 페인트를 덧칠하려고 합니다.

벽 전체를 새로 칠하기보다, 일부 구역만 덧칠해서 예산을 절감하려고 하며, 벽은 총 `n`미터이고 1미터 단위로 구역이 나뉘어 있으며 왼쪽부터 오른쪽까지 1번부터 `n`번까지 번호가 매겨져 있습니다.

`section` 리스트에는 다시 페인트칠이 필요한 구역 번호들이 오름차순으로 담겨 있습니다.

이때, 페인트를 칠하는 롤러의 길이는 `m`미터이며, 한 번 칠할 때 롤러는 다음 조건을 반드시 만족해야 합니다:
- 롤러는 벽을 벗어나면 안 됩니다.
- `section`에 지정된 구역을 **완전히 포함**하지 않으면 안 됩니다.

즉, 롤러는 항상 벽의 왼쪽 또는 오른쪽 끝에 정확히 맞춰 시작해서 `m`미터만큼 연속된 구역을 한 번에 칠할 수 있으며, 필요한 구역을 정확히 포함하도록 여러 번 칠해야 할 수도 있습니다.

모든 필요한 구역을 덧칠하기 위해 최소 몇 번의 롤링이 필요한지 구하는 함수를 작성하세요.

---

### Constraints
- 1 ≤ `m` ≤ `n` ≤ 100,000
- 1 ≤ `section`의 길이 ≤ `n`
- `section`의 각 원소는 1 이상 `n` 이하의 자연수
- `section`에는 중복된 원소가 없으며, 오름차순 정렬되어 있음

---

### Example

- Input:
```python
n = 8
m = 4
section = [2, 3, 6]
```

- Output:
```python
2
```

---

## 🐍 Python Reference Code
```python
def solution(n, m, section):
    count = 0
    i = 0
    while i < len(section):
        start = section[i]
        end = start + m - 1
        count += 1
        while i < len(section) and section[i] <= end:
            i += 1
    return count
```

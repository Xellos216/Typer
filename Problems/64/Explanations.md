## 🔹 set()
- 순서가 없는 고유한 요소들의 컬렉션을 생성합니다.
- 빠른 포함 여부 확인 및 차집합 연산 등에 유용합니다.

## 🔹 sorted(iterable)
- 반복 가능한 객체의 모든 요소를 오름차순으로 정렬한 새로운 리스트를 반환합니다.
- 가장 낮은 학생 번호부터 순차적으로 탐색할 수 있도록 결정적인 순서를 보장합니다.

## 🔹 list.remove(x)
- 리스트 또는 집합에서 x의 첫 번째 등장 요소를 제거합니다.
- 여기서는 set에 사용되어 해당 요소를 단순히 제거(discard) 하는 역할을 합니다.

---

## 📌 핵심 조건 정리
1. 같은 학생 번호가 `lost`와 `reserve`에 모두 존재하면, 그 학생은 **자기 옷만 남아 대여 불가**  
2. 체육복은 **인접 학생**(`i ± 1`)에게만 빌려줄 수 있음  
3. 한 벌의 여분은 **한 번만** 빌려줄 수 있음  
4. 빌려주기 결과로 체육복을 가진 학생 수가 **최대**가 되도록 해야 함  

## 🔍 풀이 로직
1. `real_lost = set(lost) - set(reserve)`  
   `real_reserve = set(reserve) - set(lost)`  
   → 대여 가능자·필요자 확정
2. `real_reserve`를 **오름차순 순회**하며  
   `r − 1` → `r + 1` 순으로 이웃에게 대여 (그리디)  
   → 한 번 빌려주면 `real_lost`에서 제거 
3. 최종적으로 체육복이 없는 인원 수 = `len(real_lost)`  
   **참여 가능 인원** = `n − len(real_lost)` 반환

### 배열 기반 대안
- 모든 학생의 옷 개수를 배열 `clothes`로 관리 (0,1,2)  
- 앞번호 → 뒷번호 순서로 순회하며 부족 시 이웃에게 차감·추가  
- 최종 `clothes[i] > 0`인 학생 수를 합산
